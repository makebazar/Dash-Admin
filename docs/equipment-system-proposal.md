# Техническое задание и план модернизации системы управления оборудованием

## 1. Анализ текущего состояния
Текущая система представляла собой базовый реестр (CRUD) с минимальными возможностями фильтрации.
**Выявленные проблемы:**
*   Отсутствие истории перемещений и ремонтов.
*   Бинарный статус ("Активен/Нет") не отражает реальных процессов (ремонт, диагностика, списание).
*   Нет массовых операций (неудобно при инвентаризации).
*   Нет аналитики и сводных данных на странице списка.

## 2. Разработанное решение (Прототип)
В рамках задачи был разработан и внедрен новый интерфейс `/equipment/inventory`, включающий:
*   **Дашборд-метрики:** Сводка по количеству, состоянию и стоимости оборудования.
*   **Умная таблица:** Поддержка массового выделения, визуальные бейджи статусов.
*   **Расширенная фильтрация:** Поиск, Тип, Локация, Статус.
*   **Карточка оборудования 2.0:** Вкладки "Основные данные", "Обслуживание" (регламенты), "История" (лог событий).

## 3. Техническое задание на Backend (Необходимые доработки)

Для полноценной работы нового интерфейса необходимо расширить структуру базы данных (Schema Prisma) и API.

### 3.1. Изменения в модели данных (Prisma Schema)

```prisma
// Новое перечисление статусов
enum EquipmentStatus {
  ACTIVE          // В эксплуатации
  STORAGE         // На складе
  DIAGNOSTICS     // На диагностике
  REPAIR          // В ремонте
  WRITTEN_OFF     // Списано
  SOLD            // Продано
}

model Equipment {
  id              String          @id @default(cuid())
  // ... существующие поля ...
  
  // Новые поля
  status          EquipmentStatus @default(ACTIVE)
  purchaseDate    DateTime?
  purchasePrice   Decimal?        @db.Decimal(10, 2)
  inventoryNumber String?         @unique // Инвентарный номер (отдельно от S/N)
  
  // Связи
  history         EquipmentLog[]
  maintenance     MaintenanceTask[]
}

// Новая модель для истории
model EquipmentLog {
  id          String    @id @default(cuid())
  equipmentId String
  equipment   Equipment @relation(fields: [equipmentId], references: [id])
  
  action      String    // CREATE, UPDATE, MOVE, STATUS_CHANGE, REPAIR
  details     Json?     // Детали изменения (было -> стало)
  userId      String    // Кто внес изменения
  createdAt   DateTime  @default(now())
}
```

### 3.2. Требования к API

1.  **GET /api/equipment**:
    *   Добавить поддержку фильтрации по массиву статусов (`status=ACTIVE,REPAIR`).
    *   Добавить сортировку (`sortBy=purchaseDate`).
    *   Возвращать агрегированную статистику (counts по статусам) в мета-данных ответа.

2.  **PATCH /api/equipment/bulk**:
    *   Новый эндпоинт для массовых операций.
    *   Body: `{ ids: string[], action: 'SET_STATUS', value: 'REPAIR' }`.

3.  **GET /api/equipment/:id/history**:
    *   Получение лога действий для вкладки "История".

## 4. План поэтапного внедрения

### Этап 1: Подготовка (Выполнено частично)
*   [x] Разработка нового UI/UX (Прототип внедрен).
*   [ ] Согласование модели статусов с бизнесом.

### Этап 2: Миграция данных (Backend)
*   [ ] Создание миграции БД (добавление полей `status`, `history`).
*   [ ] Скрипт миграции: Конвертация `is_active=false` -> `WRITTEN_OFF` (или STORAGE, требует уточнения).
*   [ ] Обновление API эндпоинтов для поддержки новых полей.

### Этап 3: Интеграция функционала
*   [ ] Подключение вкладки "История" к реальному API.
*   [ ] Реализация логики массовых действий на бэкенде.
*   [ ] Настройка уведомлений (Cron-job для проверки `cleaning_interval` и отправки уведомлений техникам).

### Этап 4: Тестирование и запуск
*   [ ] Тестирование сценариев инвентаризации.
*   [ ] Обучение персонала (администраторов) работе с новыми статусами.
